# Finnplay test task for front-end developer

Script to run for dev environment:

### `npm run dev`

### Only two users are hard coded to backend, so you can login with:

- `User name: player1, Password: player1`
- `User name: player2, Password: player2`

Runs the app in the development mode.\
Open [http://localhost:3002](http://localhost:3002) to view it in the browser.

## Project structure

```
src
 ├── index.tsx                 -> Entry point of the app
 ├─> api                       -> API related utilities
 │   └── index.ts              -> Simple fetch wrapper functions for API calls
 ├─> app                       -> High level components & configs
 │   ├── App.tsx               -> Main component, renders Routes
 │   ├── rootReducer.ts        -> Reducers are combined here
 │   ├── Routes.tsx            -> Routes
 │   └── store.ts              -> Redux store configurations
 ├─> components                -> "Dumb" components, do not usually subscribe to Redux state
 │   └── Component             -> Component will be rendered by container or other component
 ├─> containers                -> Smart components (containers, views, screens...)
 │   └── Container             -> Container will contain Container component and redux slice
 |    └── Container.tsx        -> Container will handle heavy logic, and pass data to children
 ├─> ducks                     -> Ducks reducer bundles
 |-> hooks                     -> Reusable hooks
 └─> utils                     -> Utility function
     └── restDuckGenerator.ts  -> Duck generator function for REST resources

```

## Utilities

This project uses RESTful API as its backend. Due to this, there is a generic reducer / action generator which is able to generate Redux reducer bundles, [Ducks](https://github.com/erikras/ducks-modular-redux), automatically for given endpoint. This reduces the usual heavy Redux boilerplate code to minimum. The generator utilizes [Redux Toolkit](https://redux-toolkit.js.org/).

For example, the Redux config (including basic selectors) for "users" endpoint for the https://reqres.in/ API looks like this when utilizing the generator:

```Typescript
import createRestDuck from "../utils/restDuckGenerator";
import { RootState } from "../app/store";

export interface User {
  id: string;
  email: string;
  first_name: string;
  last_name: string;
  avatar: string;
}

const { reducer, adapter, actions } = createRestDuck<User>("users");

export const {
  selectById: selectUserById,
  selectIds: selectUserIds,
  selectEntities: selectUserEntities,
  selectAll: selectAllUsers,
  selectTotal: selectTotalUsers,
} = adapter.getSelectors((state: RootState) => state.users);

export { reducer, actions, adapter };

```

This will create the state structure for users:

```Typescript
{
  ids: (number | string)[], // id's of the users in the entities dictionary
  entities: Dictionary<User>, // actual User entities
  // status flags for async actions
  isFetchingOne: boolean,
  isFetchingMany: boolean,
  isUpdating: boolean,
	isUpdatingMany: boolean,
  isDeletingOne: boolean,
	isDeletingAll: boolean,
	isDeletingMany: boolean,
  isCreating: boolean,
	error: {
		isError: boolean,
		message: string
	}
}
```

The state shape is normalized. Without normalization the state would be very complex and unmanageable. Normalized state is also highly recommended by official [Redux docs](https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape). The `ids` list and `entities` dictionary come from Redux Toolkit's [createEntityAdapter](https://redux-toolkit.js.org/api/createEntityAdapter).

Using the autogenerated async action creators:

```Typescript
import { actions as userActions } from "../ducks/usersDuck";

dispatch(userActions.get()) // or with params dispatch(userActions.get("queryParam=value"))
dispatch(userActions.getWithId('uuid'))
dispatch(userActions.getOne(1))
dispatch(userActions.create(User))
dispatch(userActions.update(User))
dispatch(userActions.updateMany([User]))
dispatch(userActions.removeOne(1))
dispatch(userActions.removeMany({id: 'uuid', data: [User]}))
dispatch(userActions.removeAll({id: 'uuid', data: [User]}))
```

If custom reducers and actions are needed for some additional global state, it's recommended to follow the Ducks-pattern to add some custom reducers and actions with the help of the Redux Toolkit.

## REST API structure

This project expects that the REST API follows certain requirements which are often considered as best practices. In the following examples you can replace "resources" with any possible entity you can come up with (users, cars, vehicles, devices etc.).

The top level of the returned JSON payload should have following structure (this can be extended with more properties):

```Typescript
{
  message: string, // optional message for example if the endpoint fails
  data: Array<Resource> | Resource // list of resources or single resource depending on the endpoint
}
```

The endpoints should be built like this:

- GET /resources -> returns a list of resources in the data property
- GET /resources/{id} -> returns resource with given id in the data property
- POST /resources -> creates a new resource when a resource is sent as the payload the endpoint, returns the new resource in the data property
- PUT /resources/{id} -> updates the resource which matches the id with the new values given in the payload, returns the updated resource in the data property
- DELETE /resources/{id} -> deletes the resource which matches the id
